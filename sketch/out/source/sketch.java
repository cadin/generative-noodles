/* autogenerated by Processing revision 1292 on 2023-11-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import processing.svg.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import themidibus.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class sketch extends PApplet {

// Main sketch file




Boolean USE_RETINA = true;
String SETTINGS_PATH = "config/settings.json";
String configPath = "config/config.json";
String TWIST_PATH = "graphics/twist.svg";
String TWIST_FILL_PATH = "graphics/twistFill.svg";

float MAX_SCREEN_SCALE = 0.182f * 2; // % - (0.2456 == macbook 1:1) (0.182 == LG Screen)
float SCREEN_SCALE = 0.182f * 2; 
float PRINT_W_INCHES = 11;
float PRINT_H_INCHES = 14;
int PRINT_RESOLUTION = 300;
float MARGIN_INCHES = 0.5f;

float MAT_W_INCHES = 10.75f;
float MAT_H_INCHES = 13.75f;

int TILE_SIZE = 50;
int GRID_W = 11;
int GRID_H = 11;

int PRINT_X = 0;
int PRINT_Y = 0;

int canvasW = PApplet.parseInt(PRINT_W_INCHES * PRINT_RESOLUTION * SCREEN_SCALE);
int canvasH = PApplet.parseInt(PRINT_H_INCHES * PRINT_RESOLUTION * SCREEN_SCALE);

int canvasX = 0;
int canvasY = 0;

boolean EDIT_MODE = false;
boolean BLACKOUT_MODE = false;
boolean CELLTYPE_MODE = false;
boolean PATH_EDIT_MODE = false;
int editingNoodle = 0;
int[][] blackoutCells;

boolean saveFile = false;

Noodle noodle; 
Noodle noodle2;

int numNoodles = 3;
Noodle[] noodles;

PShape twist;
PShape twistFill;

Point[][] paths;
int[][] cells;

// SETTINGS
boolean showGrid = false;
boolean useTwists = true;
boolean useJoiners = true;
boolean useCurves = true;
float penSizeMM = 0.35f;
float strokeSize = calculateStrokeSize();
float noodleThicknessPct = 0.5f;
GraphicSet[] graphicSets;
boolean randomizeEnds = false;
boolean allowOverlap = true;
boolean showInfoPanel = false;
boolean useRoughLines = false;
boolean useFills = true;

int minLength = 200;
int maxLength = 200;

ImageSaver imgSaver = new ImageSaver();
String fileNameToSave = "";

Editor editor;


boolean shiftIsDown = false;


PFont menloFont;

public void settings() {
	
	// size(displayWidth, displayHeight - 45);
	size(1920, 1080);
	// fullScreen();
	if(USE_RETINA){
		pixelDensity(displayDensity());
	}
}

public void setup() {
	editor = new Editor(this);
	frameRate(12);
	// setupController();
	menloFont = createFont("Menlo", 12);

	loadSettings(SETTINGS_PATH);
	loadConfigFile(configPath, "");

	twist = loadShape(TWIST_PATH);
	twist.disableStyle();
	twistFill = loadShape(TWIST_FILL_PATH);
	twistFill.disableStyle();
	
	colorMode(HSB, 360, 100, 100);
	reset();
}


public float calculateStrokeSize() {
	float size = (penSizeMM * 0.03937008f) * PRINT_RESOLUTION * SCREEN_SCALE; 
	return size;
}

public void calculateScreenScale() {
	float maxW = width - 100;
	float maxH = height - 100;
	
	float printW = PRINT_W_INCHES * PRINT_RESOLUTION;
	float printH = PRINT_H_INCHES * PRINT_RESOLUTION;
	SCREEN_SCALE = maxW / printW;
	
	if(printH * SCREEN_SCALE > maxH){
		SCREEN_SCALE = maxH / printH;
	}
	
	if(SCREEN_SCALE > MAX_SCREEN_SCALE){
		SCREEN_SCALE = MAX_SCREEN_SCALE;
	}
	
	canvasW = PApplet.parseInt(PRINT_W_INCHES * PRINT_RESOLUTION * SCREEN_SCALE);
	canvasH = PApplet.parseInt(PRINT_H_INCHES * PRINT_RESOLUTION * SCREEN_SCALE);
	
	canvasX = (width - canvasW) /2;
	canvasY = (height - canvasH) /2;
}

public void calculateTileSize() {
	int marginPx = PApplet.parseInt(MARGIN_INCHES * PRINT_RESOLUTION * SCREEN_SCALE);
	int printAreaW = canvasW - marginPx * 2;
	int printAreaH = canvasH - marginPx * 2;
	TILE_SIZE = printAreaW / GRID_W;
	
	if(GRID_H * TILE_SIZE > printAreaH){
		TILE_SIZE = printAreaH / GRID_H;
	}
	
	// tile size must be even
	TILE_SIZE = (TILE_SIZE / 2) * 2;
	
	PRINT_X =  (canvasW - (TILE_SIZE * GRID_W)) / 2;
	PRINT_Y = (canvasH - (TILE_SIZE * GRID_H)) / 2;
}

int paperColor = color(255);
public void drawPaperBG() {
	fill(paperColor);
	stroke(80);
	strokeWeight(1);
	rect(canvasX, canvasY, canvasW, canvasH);
}

public void drawBG() {
	background(100);
	if(imgSaver.isBusy()){ drawSaveIndicator();}
	drawPaperBG();
	
}

public void draw() {
	colorMode(RGB, 255,255,255);
	
	pushMatrix();
		drawBG();
		if(showInfoPanel) drawInfoPanel();
		
		translate(canvasX, canvasY);
		if(imgSaver.state == SaveState.SAVING){
			beginRecord(SVG, "output/" + fileNameToSave + ".svg");
		}

		translate(PRINT_X, PRINT_Y);
		if(showGrid){ drawGrid();}
		
		colorMode(HSB, 360, 100, 100);
		for(int i=0; i < noodles.length; i++){
			if(noodles[i] != null){
				noodles[i].draw(TILE_SIZE, noodleThicknessPct, useTwists);
			}
		}	
		
		
		if(imgSaver.state == SaveState.SAVING) { endRecord(); }
		imgSaver.update();
	popMatrix();
	if(EDIT_MODE) {
		editor.draw();
	} 
}

public int[][] copyBlackoutCells() {
	int[][] cells = new int[GRID_W][GRID_H];
	for(int col = 0; col < GRID_W; col++){
		cells[col] = new int[GRID_H];
		for(int row = 0; row < GRID_H; row++){
			if(blackoutCells[col][row] > 0){
				cells[col][row] = CellType.BLACKOUT;
			}
		}
	}
	return cells;
}

public void updateBlackoutCells() {
	if(blackoutCells == null || GRID_W != blackoutCells.length || GRID_H != blackoutCells[0].length){
		blackoutCells = new int[GRID_W][GRID_H];
	}
}

public void updateKeyDimensions() {
	updateBlackoutCells();
	calculateScreenScale();
	calculateTileSize();
	strokeSize = calculateStrokeSize();
}

public int getColorForCellType(int cellType) {
	int[] colors = { 
		color(0, 5),
		color(0, 255, 0, 100),
		color(0, 0, 255, 100),

		color(255, 0, 0, 100),
		color(255, 0, 0, 100),
		color(255, 0, 0, 100),
		color(255, 0, 0, 100),

		color(255, 255, 0, 100),
		color(255, 255, 0, 100),

		color(0),
		color(0),

		color(255, 0, 255, 100)};

	return colors[cellType];
}

public void reset() {
	updateKeyDimensions();

	cells = copyBlackoutCells();
	noodles = new Noodle[numNoodles];
	
	int hueRange = 200;//floor(random(0, 310));
	// int sat = floor(random(60, 80));
	// int brt = floor(random(80, 100));
	
	int noodleCount = 0;
	for(int i=0; i < numNoodles; i++){
		Point[] p = createNoodlePath(cells);
		
		if(p != null){
			int graphicIndex = floor(random(0, graphicSets.length));
			GraphicSet gfx = graphicSets[graphicIndex];
			PShape head = gfx.head;
			PShape tail = gfx.tail;

			if(randomizeEnds){
				int tailIndex = floor(random(0, graphicSets.length));
				tail = graphicSets[tailIndex].head;
			}
			
			
			int hue = floor(random(hueRange, hueRange + 50));
			// int hue = (hueRange + noodleCount * 3) % 360;
			int sat = 70; //floor(random(60, 80));
			int brt = 90; //floor(random(80, 100));
			int fillColor = color(hue, sat, brt);
			noodles[noodleCount] = new Noodle(p, TILE_SIZE, head, tail, gfx.joiners, twist, twistFill, fillColor, millis());
			noodleCount++;
		}
	}
	
	noodles = (Noodle[]) subset(noodles, 0, noodleCount);
}

public void deleteNoodle(int indexToDelete) {
	if(noodles.length <= 1) return; // don't delete all the noodles

	Noodle[] updatedNoodles = new Noodle[noodles.length - 1];
	int fillIndex = 0;
	for(int i = 0; i < noodles.length; i++){
		if(i != indexToDelete){
			updatedNoodles[fillIndex] = noodles[i];
			fillIndex++;
		}
	}
	noodles = updatedNoodles;
	editingNoodle = min(editingNoodle, noodles.length - 1);
	
}

public void keyReleased() {
	if(keyCode == SHIFT){
		shiftIsDown = false;
	}
}

public void keyPressed() {
	switch(keyCode){
		case SHIFT:
			shiftIsDown = true;
		break;
		case BACKSPACE:
			if(PATH_EDIT_MODE){
				deleteNoodle(editingNoodle);
			}
		break;
	}
	switch(key) {
		case 's' :
			fileNameToSave = getFileName();
			int _plotW = PApplet.parseInt(PRINT_W_INCHES * PRINT_RESOLUTION * SCREEN_SCALE);
			int _plotH = PApplet.parseInt(PRINT_H_INCHES * PRINT_RESOLUTION * SCREEN_SCALE);
			if(USE_RETINA){
				_plotW = _plotW * 2;
				_plotH = _plotH * 2;
			}

			imgSaver.begin(PRINT_W_INCHES, PRINT_H_INCHES, _plotW, _plotH, fileNameToSave);
		break;
		case 'g':
			showGrid = !showGrid;
			if(!showGrid){
				BLACKOUT_MODE = false;
				PATH_EDIT_MODE = false;
			}
		break;
		case 'r':
			reset();
		break;
		case 't':
			TILE_SIZE++;
		break;
		case 'e':
			EDIT_MODE = !EDIT_MODE;
			if(EDIT_MODE){
				editor.show();
			} else {
				editor.hide();
				// reset();
			}
		break;
		case 'x':
			BLACKOUT_MODE = !BLACKOUT_MODE;
			if(BLACKOUT_MODE){
				showGrid = true;
			}
		break;
		case 'p' :
			PATH_EDIT_MODE = !PATH_EDIT_MODE;
			if(PATH_EDIT_MODE){
				showGrid = true;
			}
		break;
		case 'l' :
			selectConfigFile();
		break;

		case 'c' :
			CELLTYPE_MODE = !CELLTYPE_MODE;
			break;
		case 'i' :
			importMaskImage();
			break;
		case 'I' :
			if(maskImage != null){
				processMaskData();
			} else {
				importMaskImage();
			}
			break;
	}
}

public void mouseDragged() {
	
	if(BLACKOUT_MODE){
		Point cell = getCellForMouse(mouseX, mouseY);
		if(cell.x >= 0 && cell.y >= 0 && cell.x < blackoutCells.length && cell.y < blackoutCells[0].length){
			if(isDrawing){
				blackoutCells[cell.x][cell.y] = CellType.BLACKOUT;
			} else {
				blackoutCells[cell.x][cell.y] = 0;
			}
		} 
	}
}

boolean isDrawing = true;
public void mousePressed() {
	Point cell = getCellForMouse(mouseX, mouseY);

	if(BLACKOUT_MODE){
		if(cell.x >= 0 && cell.y >= 0 && cell.x < blackoutCells.length && cell.y < blackoutCells[0].length){
			if(blackoutCells[cell.x][cell.y] > 0){
				isDrawing = false;
				blackoutCells[cell.x][cell.y] = 0;
			} else {
				isDrawing = true;
				blackoutCells[cell.x][cell.y] = CellType.BLACKOUT;
			}
		} 
	} else if(PATH_EDIT_MODE){
		if(shiftIsDown){
			editingNoodle = findNoodleWithCell(cell.x, cell.y);
		} else {
			if(pathContainsCell(noodles[editingNoodle].path, cell.x, cell.y)){
				if(cellIsEndOfPath(cell.x, cell.y, noodles[editingNoodle].path)){
					Point[] newPath = removeCellFromPath(cell.x, cell.y, noodles[editingNoodle].path);
					noodles[editingNoodle].path = newPath;
				} else {
					Point[] newPath = cycleCellType(cell.x, cell.y, noodles[editingNoodle].path);
					noodles[editingNoodle].path = newPath;
				}
			} else {
				Point[] newPath = addCellToPath(cell.x, cell.y, noodles[editingNoodle].path);
				noodles[editingNoodle].path = newPath;
			}
		}
	}
}

public void drawSaveIndicator() {
	pushMatrix();
		fill(color(200, 0, 0));
		noStroke();
		rect(0,0,width, 4);
	popMatrix();
}

public boolean pathContainsCell(Point[] path, int col, int row) {
	for(Point p : path){

		if(p != null && p.x == col && p.y == row){
			return true;
		}
	}

	return false;
}

public void drawCellTypes() {
	pushMatrix();
	noFill();
	stroke(200);
	strokeWeight(1);
	for(int row = 0; row < GRID_H; row++){
		for(int col = 0; col < GRID_W; col++){
			if(BLACKOUT_MODE && blackoutCells[col][row] > 0){
				fill(0,25);
			} else if(PATH_EDIT_MODE && pathContainsCell(noodles[editingNoodle].path, col, row)) {
				fill(0, 255, 0, 25);
			} else if(CELLTYPE_MODE){
				fill(getColorForCellType(cells[col][row]));
			} else {
				noFill();
			}
			rect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
		}
	}
	popMatrix();
}
public void drawGridLines() {
	pushMatrix();
	stroke(200);
	strokeWeight(1);
	for(int row = 0; row <= GRID_H; row++){
		line(0, row * TILE_SIZE, GRID_W * TILE_SIZE, row * TILE_SIZE);
	}

	for(int col = 0; col <= GRID_W; col++){
		line(col * TILE_SIZE, 0, col * TILE_SIZE, GRID_H * TILE_SIZE);
	}
	popMatrix();
}

public void drawGrid() {

	if(BLACKOUT_MODE || PATH_EDIT_MODE || CELLTYPE_MODE){
		if(imgSaver.state != SaveState.SAVING){
			drawCellTypes();
		}
	} 
	
	drawGridLines();

	// if(mask != null){
	// 	image(mask, 0, 0);
	// }
}

public String getFileName() {
	String d  = str( day()    );  // Values from 1 - 31
	String mo = str( month()  );  // Values from 1 - 12
	String y  = str( year()   );  // 2003, 2004, 2005, etc.
	String s  = str( second() );  // Values from 0 - 59
 	String min= str( minute() );  // Values from 0 - 59
 	String h  = str( hour()   );  // Values from 0 - 23

 	String date = y + "-" + mo + "-" + d + " " + h + "-" + min + "-" + s;
 	String n = date;
 	return n;
}
static class CellType {

    static int EMPTY = 0;
    static int VERTICAL = 1;
    static int HORIZONTAL = 2;

    static int CORNER_TL = 3;
    static int CORNER_TR = 4;
    static int CORNER_BR = 5;
    static int CORNER_BL = 6;

    static int JOIN = 7;
    static int TWIST = 8;

    static int V_CROSSED = 9;
    static int H_CROSSED = 10;

    static int OCCUPIED = 11;
    static int BLACKOUT = 12;
}
class Editor {
	
	ControlP5 cp5;
	int bgColor = color(25);
	
	Numberbox widthControl, 
	          heightControl,
	          marginControl,
	          colsControl,
	          rowsControl,
	          penSizeControl,
	          numNoodlesControl,
	          thicknessControl,
			  minLengthControl,
			  maxLengthControl;

	Toggle twistControl,
	       joinControl,
	       overlapControl,
		   randomizeEndsControl,
		   roughLinesControl,
		   useFillsControl;
	
	boolean controlsVisible = false;
		
	float printW;
	float printH;
	
	
	Editor(PApplet app) {
		cp5 = new ControlP5(app);
		PFont font = createFont("DIN", 12 / pixelDensity);
		cp5.setFont(font);
		
		widthControl = cp5.addNumberbox("Width")
			.setPosition(100,100)
			.setSize(100,20)
			.setRange(5.0f,24.0f)
			.setMultiplier(0.25f) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(PRINT_W_INCHES)
			.setDecimalPrecision(2)
			.setId(1)
			;
			
		heightControl = cp5.addNumberbox("Height")
			.setPosition(100,150)
			.setSize(100,20)
			.setRange(5.0f, 24.0f)
			.setMultiplier(0.25f) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(MARGIN_INCHES)
			.setDecimalPrecision(2)
			.setId(2)
			;
		
		marginControl = cp5.addNumberbox("Margin")
			.setPosition(100,200)
			.setSize(100,20)
			.setRange(0.0f,5.0f)
			.setMultiplier(0.25f) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(PRINT_H_INCHES)
			.setDecimalPrecision(2)
			.setId(2)
			;

		colsControl = cp5.addNumberbox("Columns")
			.setPosition(100,275)
			.setSize(100,20)
			.setRange(1,400)
			.setMultiplier(1) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(GRID_W)
			.setDecimalPrecision(0)
			.setId(3)
			;
			
		rowsControl = cp5.addNumberbox("Rows")
			.setPosition(100,325)
			.setSize(100,20)
			.setRange(1,400)
			.setMultiplier(1) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(GRID_H)
			.setDecimalPrecision(0)
			.setId(4)
			;

		
		numNoodlesControl = cp5.addNumberbox("Noodles")
			.setPosition(100,400)
			.setSize(100,20)
			.setRange(1,800)
			.setMultiplier(1) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(penSizeMM)
			.setDecimalPrecision(0)
			.setId(6)
			;
		thicknessControl = cp5.addNumberbox("Thickness %")
			.setPosition(100,450)
			.setSize(100,20)
			.setRange(0.1f,1.0f)
			.setMultiplier(0.01f) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(penSizeMM)
			.setDecimalPrecision(2)
			.setId(7)
			;

		minLengthControl = cp5.addNumberbox("Min Length")
			.setPosition(100,500)
			.setSize(100,20)
			.setRange(2,400)
			.setMultiplier(1) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(penSizeMM)
			.setDecimalPrecision(0)
			.setId(8)
			;

		maxLengthControl = cp5.addNumberbox("Max Length")
			.setPosition(100,550)
			.setSize(100,20)
			.setRange(2,400)
			.setMultiplier(1) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(penSizeMM)
			.setDecimalPrecision(0)
			.setId(9)
			;

		
		penSizeControl = cp5.addNumberbox("Pen Size")
			.setPosition(100,625)
			.setSize(100,20)
			.setRange(0.10f,6)
			.setMultiplier(0.05f) // set the sensitifity of the numberbox
			.setDirection(Controller.HORIZONTAL) // change the control direction to left/right
			.setValue(penSizeMM)
			.setDecimalPrecision(2)
			.setId(5)
			;
		
		twistControl = cp5.addToggle("Use Twists")
			.setPosition(250,100)
			.setSize(20,20)
			.setValue(useTwists)
			;
		
		twistControl
			.getCaptionLabel()
			.align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER)
			.setPaddingX(10)
			;
		
		joinControl = cp5.addToggle("Use Joins")
			.setPosition(250,150)
			.setSize(20,20)
			.setValue(useJoiners)
			;
		
		joinControl
			.getCaptionLabel()
			.align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER)
			.setPaddingX(10)
			;
			
		overlapControl = cp5.addToggle("Allow Overlaps")
			.setPosition(250,200)
			.setSize(20,20)
			.setValue(allowOverlap)
			;
		
		overlapControl
			.getCaptionLabel()
			.align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER)
			.setPaddingX(10)
			;

		randomizeEndsControl = cp5.addToggle("Randomize Ends")
			.setPosition(250,250)
			.setSize(20,20)
			.setValue(useCurves)
			;
		
		randomizeEndsControl
			.getCaptionLabel()
			.align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER)
			.setPaddingX(10)
			;
		
		roughLinesControl = cp5.addToggle("Rough Lines")
			.setPosition(250,300)
			.setSize(20,20)
			.setValue(useRoughLines)
			;
		
		roughLinesControl
			.getCaptionLabel()
			.align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER)
			.setPaddingX(10)
			;
			
		useFillsControl = cp5.addToggle("Use Fills")
			.setPosition(250,350)
			.setSize(20,20)
			.setValue(useRoughLines)
			;
		
		useFillsControl
			.getCaptionLabel()
			.align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER)
			.setPaddingX(10)
			;
		
		
		hide();
	}

	public void update() {
		widthControl.setValue(PRINT_W_INCHES);
		heightControl.setValue(PRINT_H_INCHES);
		marginControl.setValue(MARGIN_INCHES);
		colsControl.setValue(GRID_W);
		rowsControl.setValue(GRID_H);
		minLengthControl.setValue(minLength);
		maxLengthControl.setValue(maxLength);
		penSizeControl.setValue(penSizeMM);
		twistControl.setValue(useTwists);
		joinControl.setValue(useJoiners);
		overlapControl.setValue(useCurves);
		numNoodlesControl.setValue(numNoodles);
		thicknessControl.setValue(noodleThicknessPct);
		randomizeEndsControl.setValue(randomizeEnds);
		roughLinesControl.setValue(useRoughLines);
		useFillsControl.setValue(useFills);
	}
	
	
	public void show() {
		update();
		controlsVisible = true;
	}
	
	public void hide() {
		PRINT_W_INCHES = widthControl.getValue();
		PRINT_H_INCHES = heightControl.getValue();
		GRID_W = PApplet.parseInt(colsControl.getValue());
		GRID_H = PApplet.parseInt(rowsControl.getValue());
		penSizeMM = penSizeControl.getValue();
		strokeSize = calculateStrokeSize();

		useTwists = twistControl.getState();
		useJoiners = joinControl.getState();
		allowOverlap = overlapControl.getState();
		useRoughLines = roughLinesControl.getState();
		useFills = useFillsControl.getState();

		controlsVisible = false;
		cp5.hide();
		
	}
	
	public void draw() {
		fill(50, 150);
		noStroke();
		rect(50, 50, 400, 650, 8);
		
		if(controlsVisible && !cp5.isVisible()){
			cp5.show();
		} 
	}

	public boolean printSizeDidChange() {
		return (
			PRINT_W_INCHES != widthControl.getValue() || 
			PRINT_H_INCHES != heightControl.getValue() ||
			GRID_W != PApplet.parseInt(colsControl.getValue())||
			GRID_H != PApplet.parseInt(rowsControl.getValue()) ||
			MARGIN_INCHES != marginControl.getValue()
		);
	}
	
	public void controlEvent(ControlEvent e) {
		if(controlsVisible){
			boolean updateSizes = printSizeDidChange();

			PRINT_W_INCHES = widthControl.getValue();
			PRINT_H_INCHES = heightControl.getValue();
			MARGIN_INCHES = marginControl.getValue();
			GRID_W = PApplet.parseInt(colsControl.getValue());
			GRID_H = PApplet.parseInt(rowsControl.getValue());
			penSizeMM = penSizeControl.getValue();
			strokeSize = calculateStrokeSize();
			minLength = PApplet.parseInt(minLengthControl.getValue());
			maxLength = PApplet.parseInt(maxLengthControl.getValue());

			useTwists = twistControl.getState();
			useJoiners = joinControl.getState();
			allowOverlap = overlapControl.getState();
			numNoodles = PApplet.parseInt(numNoodlesControl.getValue());
			noodleThicknessPct = thicknessControl.getValue();
			randomizeEnds = randomizeEndsControl.getState();
			useRoughLines = roughLinesControl.getState();
			useFills = useFillsControl.getState();

			if(updateSizes){
				updateKeyDimensions();
			}
		}
		// println(" - got a control event from controller with id " + e.getId());
		// switch(theEvent.getId()) {
		// 	case(1): // numberboxA is registered with id 1
		// 		println((theEvent.getController().getValue()));
		// 	break;
		// 	case(2):  // numberboxB is registered with id 2
		// 		println((theEvent.getController().getValue()));
		// 	break;
		// }
	}
}

public void controlEvent(ControlEvent e) {
	// forward control events to Editor
	if(editor != null){
		editor.controlEvent(e);
	}
}
class GraphicSet {

    String headPath;
    String tailPath;
    String[] joinerPaths;

    PShape head;
    PShape tail;
    PShape[] joiners;

    GraphicSet(JSONObject obj){
        if(!obj.isNull("head")){
            headPath = obj.getString("head");
        }
        if(!obj.isNull("tail")){
            tailPath = obj.getString("tail");
        }

        if(!obj.isNull("joiners")){
            JSONArray joins = obj.getJSONArray("joiners");
            joinerPaths = new String[joins.size()];
            for(int i = 0; i < joins.size(); i++) {
                joinerPaths[i] = joins.getString(i);
            }
        }
    }

    public void loadShapes() {
        if(headPath != null){
            head = loadShape(headPath);
            head.disableStyle();
        }

        if(tailPath != null){
            tail = loadShape(tailPath);
            tail.disableStyle();
        } else {
            tail = head;
        }

        if(joinerPaths != null && joinerPaths.length > 0){
            joiners = new PShape[joinerPaths.length];
            for(int i = 0; i < joinerPaths.length; i++){
                try {
                    joiners[i] = loadShape(joinerPaths[i]);
                    joiners[i].disableStyle();
                } catch(Exception e) {
                    println("Joiner shape not found: " + joinerPaths[i]);
                }
            }
        }
    }
}
 


class ImageSaver {

	SaveState state = SaveState.NONE;
	String filenameToSave;

	float printW, printH;
	int canvasW, canvasH;

	ImageSaver() {
		
	}
	
	public void update() {
		switch (state) {
			case BEGAN:
				println("Saving SVG file... ");
				state = SaveState.SAVING;
			break;
			case RENDER_BEGAN:
				state = SaveState.RENDERING;
			break;
			case SAVING:
				saveImageData(fileNameToSave);
				resizeSVG(fileNameToSave, printW, printH, canvasW, canvasH);
				state = SaveState.COMPLETE;
			break;
			case RENDERING:
				// runRenderQueue();
			break;
			case COMPLETE:
				println("DONE!");
				state = SaveState.NONE;
			break;	
		}
	}
	
	public boolean isBusy() {
		return state == SaveState.BEGAN || 
		       state == SaveState.SAVING || 
		       state == SaveState.RENDER_BEGAN || 
		       state == SaveState.RENDERING;
	}
	
	public void begin(float _printW, float _printH, int _canvasW, int _canvasH, String filename) {
		filenameToSave = filename;
		state = SaveState.BEGAN;

		printW = _printW;
		printH = _printH;

		canvasW = _canvasW;
		canvasH = _canvasH;
	}

	public JSONArray getBlackoutCellArray() {
		JSONArray cellArray = new JSONArray();
		for(int col = 0; col < blackoutCells.length; col++){
			JSONArray rowArray = new JSONArray();
			for(int row = 0; row < blackoutCells[0].length; row++){
				rowArray.append(blackoutCells[col][row]);
			}
			cellArray.append(rowArray);
		}
		return cellArray;
	}

	public JSONArray getGraphicSetsArray() {
		JSONArray graphicsArray = new JSONArray();
		for(int i = 0; i < graphicSets.length; i++){
			JSONObject set = new JSONObject();
			set.setString("head", graphicSets[i].headPath);
			set.setString("tail", graphicSets[i].tailPath);

			if(graphicSets[i].joinerPaths != null){
				JSONArray joinsArray = new JSONArray();
				for(int j = 0; j < graphicSets[i].joinerPaths.length; j++){
					joinsArray.setString(j, graphicSets[i].joinerPaths[j]);
				}
				set.setJSONArray("joiners", joinsArray);
			}

			graphicsArray.setJSONObject(i, set);
		}
		return graphicsArray;
	}
	
	public void saveImageData(String filename) {
		print("writing data file... ");
		
		JSONArray cellArray = getBlackoutCellArray();
		JSONArray graphicsArray = getGraphicSetsArray();
		
		JSONObject obj = new JSONObject();
		obj.setJSONArray("blackoutCells", cellArray);
		obj.setFloat("printWidthInches", PRINT_W_INCHES);
		obj.setFloat("printHeightInches", PRINT_H_INCHES);
		obj.setInt("gridWidth", GRID_W);
		obj.setInt("gridHeight", GRID_H);
		obj.setFloat("marginInches", MARGIN_INCHES);
		obj.setBoolean("useTwists", useTwists);
		obj.setBoolean("useJoiners", useJoiners);
		obj.setBoolean("allowOverlap", allowOverlap);
		obj.setFloat("noodleThicknessPct", noodleThicknessPct);
		obj.setInt("numNoodles", numNoodles);
		obj.setInt("minLength", minLength);
		obj.setInt("maxLength", maxLength);
		obj.setJSONArray("graphics", graphicsArray);
		obj.setBoolean("randomizeEnds", randomizeEnds);
		saveJSONObject(obj, "output/" + filename + ".json");
		// saveJSONArray(layersArray, "output/" + filename + ".json");
		println("done.");
	}
	
	public void resizeSVG(String filename, float wInches, float hInches, int wPx, int hPx){
		print("- resizing SVG... ");
		String[] lines = loadStrings("output/" + filename + ".svg");
		
		for(int i=0; i < lines.length; i++){
			String l = lines[i];
			if(l.length() > 4 && l.substring(0, 4).equals("<svg")){
				print(" found SVG tag... ");
				Pattern p = Pattern.compile("width=\"([0-9]+)\"");
		        Matcher m = p.matcher(l);
		        l = m.replaceAll("width=\"" + wInches + "in\"");
		        
		        Pattern p2 = Pattern.compile("height=\"([0-9]+)\"");
		        Matcher m2 = p2.matcher(l);
		        lines[i] = m2.replaceAll("height=\"" + hInches + "in\" viewBox=\"0 0 " + wPx + " " + hPx + "\"");
			}
		}
		saveStrings("output/" + filename + ".svg", lines);
		println("done!");
	}
}
class Noodle {
	int margin = 0;
	int thickness = 10;
	float thicknessPct = 0.5f;
	int tileSize = 0;
	
	int headWidth = 100;
	int seed = 0;
	
	Point[] path;
	
	PShape head, tail;
	PShape[] joiners;
	PShape twist;
	PShape twistFill;
	int fillColor;
	
	public void calculateSizes(int tileW, float pct) {
		tileSize = tileW;
		thicknessPct = pct;
		thickness = PApplet.parseInt(tileSize * thicknessPct);
		thickness = (thickness / 2) * 2;
		margin = (tileSize - thickness) / 2;
	}

	Noodle(Point[] p, int tileW, PShape h, PShape t, PShape[] j, PShape tw, PShape twf,int fc, int rs) {
		calculateSizes(tileW, thicknessPct);
		head = h;
		tail = t;
		
		joiners = j;
		twist = tw;
		twistFill = twf;
		path = p;
		fillColor = fc;

		seed = rs;
	}

	
	public void drawEnd(PShape shape, Point pos, Point neighbor, int flip) {
		pushMatrix();
		translate(tileSize / 2, tileSize/2);
		
		if(neighbor.x < pos.x){
			rotate(HALF_PI);
		} else if(neighbor.x > pos.x){
			rotate(-HALF_PI);
		} else if(neighbor.y < pos.y){
			rotate(PI);
		}
		
		float scale = (float)thickness / (float)headWidth;
		translate(0, (tileSize - headWidth * scale) / 2);
		scale(flip, 1);
		scale(scale);
		strokeWeight(strokeSize / scale);
		shape(shape, headWidth/-2 , headWidth/-2);
		strokeWeight(strokeSize);
		popMatrix();
	}
	
	public void verticalShape(PShape shape){
		verticalShape(shape, false);
	}

	public void verticalShape(PShape shape, boolean isFill) {
		float scale = (float)thickness / (float)headWidth;
		float distToGfx = (tileSize - headWidth * scale)/2;
		
		if(isFill){
			rect(margin, 0, tileSize - margin * 2, distToGfx);
			rect(margin, tileSize - distToGfx, tileSize - margin * 2, distToGfx);
		} else {
			line(margin, 0, margin, distToGfx);
			line(tileSize - margin, 0, tileSize - margin, distToGfx);
			line(margin, tileSize - distToGfx, margin, tileSize);
			line(tileSize - margin, tileSize - distToGfx, tileSize-margin, tileSize);
		}
		
		pushMatrix();
			translate(tileSize / 2, tileSize/2);
			scale(scale);
			strokeWeight(strokeSize / scale);
			shape(shape, headWidth/-2 , headWidth/-2);
			strokeWeight(strokeSize);
		popMatrix();
	}

	public void verticalTwist(boolean isFill) {
		if(isFill){
			verticalShape(twistFill, true);
		} else {
			verticalShape(twist);
		}
	}
	
	public void verticalJoin(int type) {
		verticalShape(joiners[type -1]);
	}

	public void horizontalShape(PShape shape) {
		horizontalShape(shape, false);
	}

	public void horizontalShape(PShape shape, boolean isFill) {
		float scale = (float)thickness / (float)headWidth;
		float distToGfx = (tileSize - headWidth * scale)/2;
		
		if(isFill){
			rect(0, margin, distToGfx, tileSize - margin * 2);
			rect(tileSize - distToGfx, margin, distToGfx, tileSize - margin * 2);
		} else {
		
			line(0, margin, distToGfx, margin);
			line( 0,tileSize - margin,  distToGfx, tileSize - margin);
			line(tileSize - distToGfx, margin,  tileSize, margin );
			line(tileSize - distToGfx, tileSize - margin,  tileSize, tileSize-margin);
		}
		
		pushMatrix();
			translate(tileSize / 2, tileSize/2);
			scale(scale);
			rotate(HALF_PI);
			strokeWeight(strokeSize / scale);
			shape(shape, headWidth/-2 , headWidth/-2);
			strokeWeight(strokeSize);
		popMatrix();
	}

	public void horizontalTwist(boolean isFill) {
		if(isFill){
			horizontalShape(twistFill, true);
		} else {
			horizontalShape(twist);
		}
	}
	
	public void horizontalJoin(int type) {
		horizontalShape(joiners[type-1]);
	}
	
	public void drawNoodle(boolean useTwists) {
		randomSeed(seed);
		
		boolean fills = useFills;
		int start = 1;
		if (useFills) start = 0;
		for(int j = start ; j < 2; j++){
			
			for(int i = 0; i < path.length; i++){
				
				if(j == 0){
					noStroke();
					fill(fillColor);
					
				} else {
					fills = false;
					stroke(0);
					noFill();
					strokeWeight(strokeSize);
				}
				Point p = path[i];
				
				pushMatrix();
				translate(p.x * tileSize, p.y * tileSize);
				if(i == 0){
					drawEnd(head, path[i], path[i + 1], 1);
				}else if( i == path.length -1){
					drawEnd(tail, path[i], path[i - 1], -1);
				} else {
					
					Point prev = path[i-1];
					Point next = path[i+1];
					
					boolean top = prev.y < p.y || next.y < p.y;
					boolean right = prev.x > p.x || next.x > p.x;
					boolean left = prev.x < p.x || next.x < p.x;
					boolean bottom = prev.y > p.y || next.y > p.y;
					
					if(top && bottom ){
						if(p.type == CellType.V_CROSSED){
							verticalCrossed(fills);
						} else if (useTwists && p.joinType == 0){
							verticalTwist(fills);
						}  else if(useJoiners && joiners != null && p.joinType > 0 && p.joinType <= joiners.length) {
							verticalJoin(p.joinType);
						} else {
							vertical(fills);
						}
					} else if(left && right){
						if(p.type == CellType.H_CROSSED){
							horizontalCrossed(fills);
						} else if (useTwists && p.joinType == 0){
							horizontalTwist(fills);
						} else if(useJoiners && joiners != null && p.joinType > 0 && p.joinType <= joiners.length){
							horizontalJoin(p.joinType);
						} else {
							horizontal(fills);
						}
					} else if(left && bottom){
						cornerTR(fills);
					} else if(top && left){
						cornerBR(fills);
					} else if(top && right) {
						cornerBL(fills);
					} else if(bottom && right){
						cornerTL(fills);
					}
				}
				popMatrix();
				
				
			}
		}
	}
	
	public void draw(int size, float pct, boolean useTwists) {
		if(tileSize != size || thicknessPct != pct){
			calculateSizes(size, pct);
		}
		
		drawNoodle(useTwists);
	}

	public void verticalCrossed(boolean isFill) {
		if(isFill){
			// rect(margin, 0, tileSize - margin * 2, margin);
			// rect(margin , tileSize - margin, tileSize - margin * 2, margin);
			vertical(isFill);
		} else {
			line(margin, 0, margin, margin);
			line(margin, tileSize - margin, margin, tileSize );
			
			line(tileSize - margin, 0, tileSize - margin, margin);
			line(tileSize - margin, tileSize - margin, tileSize - margin, tileSize);
		}
	}

	public void horizontalCrossed(boolean isFill) {
		if(isFill){
			// rect(0, margin, margin, tileSize - margin *2);
			// rect(tileSize - margin, margin, margin, tileSize - margin *2);
			horizontal(isFill);
		} else {
			line(0, margin, margin, margin);
			line(tileSize - margin, margin, tileSize, margin);

			line(0, tileSize - margin, margin, tileSize - margin);
			line(tileSize - margin, tileSize - margin, tileSize, tileSize - margin);
		}
	}
	
	public void cornerTL(boolean isFill) {
		arc(tileSize, tileSize, (thickness + margin)*2, (thickness + margin)*2, PI, PI + HALF_PI);
		if(isFill) fill(paperColor);
		arc(tileSize, tileSize, margin * 2, margin * 2, PI, PI + HALF_PI);
	}
	
	public void cornerTR(boolean isFill) {
		arc(0, tileSize, (thickness + margin)*2 , (thickness + margin)*2,-HALF_PI, 0);
		if(isFill) fill(paperColor);
		arc(0, tileSize, margin * 2, margin *2, -HALF_PI, 0);
	}
	
	public void cornerBR(boolean isFill) {
		arc(0, 0, (thickness + margin)*2, (thickness + margin)*2, 0, HALF_PI);
		if(isFill) fill(paperColor);
		arc(0, 0, margin * 2, margin * 2, 0, HALF_PI);
	}
	
	public void cornerBL(boolean isFill) {
		arc(tileSize, 0, (thickness + margin)*2, (thickness + margin)*2, HALF_PI, PI);
		if(isFill) fill(paperColor);
		arc(tileSize, 0, margin * 2, margin * 2, HALF_PI, PI);
		
	}
	
	public void vertical(boolean isFill) {
		if(useRoughLines){
			roughLineV(margin, 0, tileSize);
			roughLineV(tileSize - margin, 0, tileSize);
		} else {
			
			if(isFill){
				rect(margin, 0, tileSize - margin*2, tileSize);
			} else {
				line(margin, 0, margin, tileSize);
				line( tileSize - margin, tileSize, tileSize - margin, 0);
			}
		}		
	}
	
	// void verticalTwist() {
	// 	float twistDepth = tileSize / 2;
	// 	bezier(margin, 0, margin,   twistDepth, tileSize - margin,   tileSize - twistDepth, tileSize-margin, tileSize);
	// 	bezier( tileSize - margin, 0,    tileSize - margin, twistDepth,     margin, tileSize - twistDepth,    margin, tileSize);
	// }
	
	
	
	public void horizontal(boolean isFill) {
		if(useRoughLines){
			roughLineH(0, margin, tileSize);
			roughLineH(0, tileSize - margin, tileSize);
		} else {
			if(isFill){
				rect(0, margin, tileSize, tileSize - margin * 2);
			} else {
				line(0, margin, tileSize, margin);
				line(0, tileSize - margin, tileSize, tileSize - margin);
			}
		}
	}
	
// 	void horizontalTwist() {
// 		float twistDepth = tileSize / 2;
// 		bezier( 0, margin, twistDepth,margin, tileSize - (twistDepth),   tileSize-margin,   tileSize , tileSize - margin);
// 		bezier( 0, tileSize - margin, twistDepth, tileSize-margin, tileSize -twistDepth, margin,      tileSize, margin);
// 	}
}
class Point {
	int x = 0;
	int y = 0;
	int type = 0;
	int joinType = 0;
	
	Point(int _x, int _y) {
		x = _x; 
		y = _y;
	}

	@Override
  	public String toString() {
    	return "{" + x + ", " + y + "}";
  	}
}
static class Utils {

    public static float roundToInterval(float val, float precision, int decimals) {
        int integer = round(val * pow(10, decimals));
        int intPrecision = round(precision * pow(10, decimals));

        int intResult = round(integer / intPrecision) * intPrecision;
        return (float) (intResult / Math.pow(10, decimals));
    }

    public static int roundToInterval(int val, float precision) {
        int intResult = round((val / precision) * precision);
        return intResult;
    }

}class XTButton {

	static final int MODE_MOMENTARY = 0;
	static final int MODE_TOGGLE = 1;

	int id = 0;
	int mode = MODE_MOMENTARY;
	boolean value = false;
	boolean toggleValue = false;
	int pitch = 0;
	XTButtonGroup group;

	XTButton(int id) {
		this.id = id;
	}

	XTButton(int id, int pitch){
		this.id = id;
		this.pitch = pitch;
	}

	public void setValue(boolean val) {
		value = val;
		toggleValue = val;
		if(this.group != null && val == true){
			group.buttonDidChange(this, value);
		}
		buttonDidChange(this, value);
	}

	public void setMode(int mode){
		this.mode = mode;
	}

	public void toggle() {
		toggleValue = !toggleValue;
	}

	public void addToGroup(XTButtonGroup group) {
		this.group = group;
	}

}

class XTButtonGroup {

	XTButton[] buttons;

	int selectedButton = 0;
	XTouchMini controller;

	XTButtonGroup(XTouchMini controller, XTButton[] buttons){
		this.buttons = buttons;
		this.controller = controller;

		for(XTButton b : this.buttons){
			b.setMode(XTButton.MODE_TOGGLE);
			b.addToGroup(this);
		}
	}

	public void buttonDidChange(XTButton button, boolean value) {
		if(buttons[selectedButton] != button) {
			controller.setValueForButton(false, buttons[selectedButton]);
		}

		selectedButton = indexOf(button);
	}

	public int indexOf(XTButton button) {
		int index = -1;
		for(XTButton b : this.buttons){
			index++;
			if(b == button){
				return index;
			}
		}
		return -1;
	}

	public boolean contains(XTButton button) {
		return indexOf(button) >= 0;
	}
}class XTFader {

	int rawValue;
	float value = 0;
	float rangeMin = 0, rangeMax = 127;

	float roundingMultiplier = 1;
	int roundingDecimals = 0;
	boolean roundValues = false;

	XTFader() {}

	public void setRange(float min, float max) {
		rangeMin = min;
		rangeMax = max;

		setRawValue(rawValue);
	}

	public void setRoundingConstraints(float multiplier, int decimals) {
		roundingMultiplier = multiplier;
		roundingDecimals = decimals;
		roundValues = true;
	}

	public void setRoundingConstraints(int multiplier) {
		this.setRoundingConstraints(multiplier, 0);
	}

	public void clearRoundingConstraints() {
		roundValues = false;
	}

	public int getRawValue() {
		return rawValue;
	}

	public int getRawValue(float val) {
		return PApplet.parseInt(map(val, rangeMin, rangeMax, 0, 127));
	}

	public void setRawValue(int val) {
		float oldValue = value;
		rawValue = val;
		value = map(val, 0, 127, rangeMin, rangeMax);

		if(roundValues){
			value = Utils.roundToInterval(value, roundingMultiplier, roundingDecimals);
		}

		faderDidChange(oldValue, this.value);
	}

	public void setValue(float val) {
		setRawValue(getRawValue(val));
	}
}

class XTKnob {

	int id = 0;
	int rawValue = 0;
	float value = 0;
	float rangeMin = 0, rangeMax = 127;
	int number = 0;

	float roundingMultiplier = 1;
	int roundingDecimals = 0;
	boolean roundValues = false; 


	XTKnob(int id, float value, float rangeMin, float rangeMax) {
		this.id = id;
		this.rangeMin = rangeMin;
		this.rangeMax = rangeMax;

		setValue(value);
	}

	XTKnob(int id, int number) {
		this.id = id;
		this.number = number;
	}

	public void setRoundingConstraints(float multiplier, int decimals) {
		roundingMultiplier = multiplier;
		roundingDecimals = decimals;
		roundValues = true;
	}

	public void clearRoundingConstraints() {
		roundValues = false;
	}

	public void setRange(float min, float max) {
		rangeMin = min;
		rangeMax = max;

		setRawValue(rawValue);
	}

	public int getRawValue() {
		return rawValue;
	}

	public int getRawValue(float val) {
		return PApplet.parseInt(map(val, rangeMin, rangeMax, 0, 127));
	}

	public void setRawValue(int val) {
		float oldValue = value;
		rawValue = val;
		this.value = map(val, 0, 127, rangeMin, rangeMax);
		if(roundValues){
			this.value = Utils.roundToInterval(value, roundingMultiplier, roundingDecimals);
		}

		knobDidChange(this, oldValue, this.value);
	}

	public void setValue(float val) {
		setRawValue(getRawValue(val));
	}
}




public class XTouchMini {
	int LAYER_A = 0, LAYER_B = 1;

	int CHANNEL = 10;

	int KNOB_INDEX_START_A = 1;
	int KNOB_INDEX_END_A = 8;
	int KNOB_INDEX_START_B = 11;
	int KNOB_INDEX_END_B = 18;

	int KNOB_BUTTON_INDEX_START_A = 0;
	int KNOB_BUTTON_INDEX_END_A = 7;
	int KNOB_BUTTON_INDEX_START_B = 24;
	int KNOB_BUTTON_INDEX_END_B = 31;

	int BUTTON_INDEX_START_A = 8;
	int BUTTON_INDEX_END_A = 23;
	int BUTTON_INDEX_START_B = 32;
	int BUTTON_INDEX_END_B = 47;

	int FADER_INDEX_A = 9;
	int FADER_INDEX_B = 10;


	boolean logMidiBusOutput = false;
	boolean resetControls = true;
	int currentLayer;
	MidiBus midiBus; // The MidiBus

	XTKnob[] _knobs;
	XTButton[] _buttons;
	int[] knobIdsByButtonPitch = new int[KNOB_BUTTON_INDEX_END_B + 1];

	// only make one fader since it can't change physical display per layer
	XTFader fader;

	XTouchMini() {
		MidiBus.list();
		midiBus = new MidiBus(this, 0, 1);

		createKnobs();
		createButtons();
		fader = new XTFader();
		if(resetControls) resetControls();
	}

	public void resetControls(){
		for(int i = 1; i <= 18; i++){
			midiBus.sendControllerChange(CHANNEL, i, 0);
		}

		for(int j=0; j < 48; j++){
			midiBus.sendNoteOff(CHANNEL, j, 0);
		}
	}

	public void createButtons() {
		_buttons = new XTButton[32];
		int pitch = BUTTON_INDEX_START_A;
		for(int i = 0; i < _buttons.length; i++){
			XTButton b = new XTButton(i+1, pitch);
			_buttons[i] = b;


			if(pitch == BUTTON_INDEX_END_A){
				pitch = BUTTON_INDEX_START_B;
			} else {
				pitch++;
			}
		}
	}

	public void createKnobs() {
		_knobs = new XTKnob[16];
		int number = KNOB_INDEX_START_A;
		int pitch = KNOB_BUTTON_INDEX_START_A;
		for(int i = 0; i < _knobs.length; i++){
			int id = i+1;
			XTKnob k = new XTKnob(id, number);
			_knobs[i] = k;

			knobIdsByButtonPitch[pitch] = id;

			if(number == KNOB_INDEX_END_A){
				number = KNOB_INDEX_START_B;
				pitch = KNOB_BUTTON_INDEX_START_B;
			} else {
				pitch++;
				number++;
			}
		}
	}

	public XTFader getFader() {
		// for consistency
		return fader;
	}

	public void setRangeForFader(float min, float max) {
		fader.setRange(min, max);
	}

	// ### KNOBS ###
	public XTKnob getKnob(int id) {
		return _knobs[id-1];
	}

	public void setRangeForKnob(float min, float max, int knobID) {
		setRangeForKnob(min, max, getKnob(knobID));
	}

	public void setRangeForKnob(float min, float max, XTKnob knob) {
		knob.setRange(min, max);
	}

	public float getValueForKnob(int knobID) {
		return getKnob(knobID).value;
	}

	public float getValueForKnob(XTKnob knob) {
		return knob.value;
	}

	public void setValueForKnob(float value, int knobID) {
		XTKnob k = getKnob(knobID);
		setValueForKnob(value, k);
	}

	public void setValueForKnob(float value, XTKnob knob) {
		int val = knob.getRawValue(value);
		midiBus.sendControllerChange(CHANNEL, knob.number, val);
		knob.setValue(value);
	}

	public void setRoundingConstraintsForKnob(float multiplier, int decimals, int knobID) {
		XTKnob k = getKnob(knobID);
		setRoundingConstraintsForKnob(multiplier, decimals, k);
	}

	public void setRoundingConstraintsForKnob(float multiplier, int decimals, XTKnob knob) {
		knob.setRoundingConstraints(multiplier, decimals);
	}

	public void setRoundingConstraintsForKnob(int multiplier, int knobID) {
		XTKnob k = getKnob(knobID);
		setRoundingConstraintsForKnob(multiplier, k);
	}

	public void setRoundingConstraintsForKnob(int multiplier, XTKnob knob) {
		knob.setRoundingConstraints(multiplier, 0);
	}

	public void clearRoundingConstraintsForKnob(int knobID){
		XTKnob k = getKnob(knobID);
		clearRoundingConstraintsForKnob(k);
	}

	public void clearRoundingConstraintsForKnob(XTKnob knob){
		knob.clearRoundingConstraints();
	}

	public void resetKnob(int knobID){
		XTKnob k = getKnob(knobID);
		resetKnob(k);
	}

	public void resetKnob(XTKnob knob) {
		knob.setRawValue(0);
		midiBus.sendControllerChange(CHANNEL, knob.number, 0);
	}

	public void maxKnob(int knobID) {
		XTKnob k = getKnob(knobID);
		maxKnob(k);
	}

	public void maxKnob(XTKnob knob) {
		knob.setRawValue(127);
		midiBus.sendControllerChange(CHANNEL, knob.number, 127);
	}


	// ### BUTTONS ###
	public XTButton getButton(int id) {
		return _buttons[id-1];
	}

	public XTButton[] getButtons(int startID, int endID){
		int len = endID - startID + 1;
		XTButton[] arr = new XTButton[len];
		int id = startID;
		for(int i = 0; i < len; i++){
			arr[i] = getButton(id);
			id++;
		}
		return arr;
	}

	public boolean getValueForButton(int buttonID) {
		return getButton(buttonID).value;
	}

	public boolean getValueForButton(XTButton button) {
		return button.value;
	}

	public void setValueForButton(boolean value, int buttonID){
		setValueForButton(value, getButton(buttonID));
	}

	public void setValueForButton(boolean value, XTButton button) {
		button.setValue(value);
		int pitch = button.pitch;
		if(value == true){
			midiBus.sendNoteOn(CHANNEL, pitch, 127);
		} else {
			midiBus.sendNoteOff(CHANNEL, pitch, 0);
		}
	}

	public void setModeForButton(int mode, int buttonID) {
		getButton(buttonID).mode = mode;
	}

	public void setModeForButton(int mode, XTButton button) {
		button.mode = mode;
	}

	public boolean pitchIsButton(int pitch) {
		return (pitch >= BUTTON_INDEX_START_A && pitch <= BUTTON_INDEX_END_A) || (pitch >= BUTTON_INDEX_START_B && pitch <= BUTTON_INDEX_END_B);
	}

	public int getButtonIdForPitch(int pitch) {
		int id = 0;
		if(pitch < 24){
			id = pitch - 7;
		} else {
			id = pitch - 15;
		}
		return id;
	}



	// ### THEMIDIBUS ###
	public void noteOn(int channel, int pitch, int velocity) {
		// Receive a noteOn

		if(pitchIsButton(pitch)){
			int id = getButtonIdForPitch(pitch);
			XTButton b = getButton(id);
			if(b.mode == XTButton.MODE_MOMENTARY || b.toggleValue == false){
				b.setValue(true);
			} else {
				b.toggle();
			}
		} else {
			// knob button
			int knobID = knobIdsByButtonPitch[pitch];
			knobDidPress(getKnob(knobID));
		}

		if(logMidiBusOutput){
			println();
			println("Note On:");
			println("--------");
			println("Channel:"+channel);
			println("Pitch:"+pitch);
			println("Velocity:"+velocity);
		}
	}

	public void noteOff(int channel, int pitch, int velocity) {
		// Receive a noteOff

		if(pitchIsButton(pitch)){
			int id = getButtonIdForPitch(pitch);

			XTButton b = getButton(id);

			if (b.mode == XTButton.MODE_MOMENTARY || b.toggleValue == false){
				b.setValue(false);
			} else {
				midiBus.sendNoteOn(CHANNEL, pitch, 127);
			}

		} else {
			// knob button
			int knobID = knobIdsByButtonPitch[pitch];
			knobDidRelease(getKnob(knobID));
		}

		if(logMidiBusOutput){
			println();
			println("Note Off:");
			println("--------");
			println("Channel:"+channel);
			println("Pitch:"+pitch);
			println("Velocity:"+velocity);
		}
	}

	public boolean controllerNumberIsFader(int number) {
		return number == FADER_INDEX_A || number == FADER_INDEX_B;
	}

	public boolean controllerNumberIsKnob(int number) {
		return (number >= KNOB_INDEX_START_A && number <= KNOB_INDEX_END_A) || (number >= KNOB_INDEX_START_B && number <= KNOB_INDEX_END_B);
	}

	public int getKnobIDFromControlNumber(int number) {
		if(number > KNOB_INDEX_END_A){
			number -= 2;
		}

		return number;
	}

	public void controllerChange(int channel, int number, int value) {
		// Receive a controllerChange

		if(controllerNumberIsKnob(number)) {
			int knobID = getKnobIDFromControlNumber(number);
			getKnob(knobID).setRawValue(value);

		} else if(controllerNumberIsFader(number)){
			fader.setRawValue(value);
		}

		if(logMidiBusOutput){
			println();
			println("Controller Change:");
			println("--------");
			println("Channel:"+channel);
			println("Number:"+number);
			println("Value:"+value);
		}
	}
}
// ### SELECT & LOAD CONFIG ###
public void selectConfigFile() {
	selectInput("Load config file", "onConfigSelected", dataFile("config"));
}

public void reloadCurrentData() {
	loadConfigFile(configPath, "");
}

public void onConfigSelected(File config) {
	shiftIsDown = false;
	if(config == null) return;
	
	String filePath = config.getAbsolutePath();
	String fileName = config.getName();
	String relativePath = new File(sketchPath("")).toURI().relativize(new File(filePath).toURI()).getPath();
	
	// remove extension from filename
	fileName = fileName.substring(0, fileName.length() - 5);
	
	if(filePath.toLowerCase().endsWith(".json")){
		loadConfigFile(relativePath, fileName);
		configPath = relativePath;
		updateSettingsFile();
		updateControllerValues();
		reset();
	}
}

public void parseConfigObject(JSONObject obj) {
	if(!obj.isNull("printWidthInches")){
		PRINT_W_INCHES = obj.getFloat("printWidthInches");
	}
	if(!obj.isNull("printHeightInches")) {
		PRINT_H_INCHES = obj.getFloat("printHeightInches");
	}
	if(!obj.isNull("printResolution")) {
		PRINT_RESOLUTION = obj.getInt("printResolution");
	}
	if(!obj.isNull("gridWidth")){
		GRID_W = obj.getInt("gridWidth");
	}
	if(!obj.isNull("gridHeight")){
		GRID_H = obj.getInt("gridHeight");
	}
	if(!obj.isNull("marginInches")){
		MARGIN_INCHES = obj.getFloat("marginInches");
	}
	if(!obj.isNull("useTwists")){
		useTwists = obj.getBoolean("useTwists");
	}
	if(!obj.isNull("useJoiners")){
		useJoiners = obj.getBoolean("useJoiners");
	}
	if(!obj.isNull("allowOverlap")){
		allowOverlap = obj.getBoolean("allowOverlap");
	}
	if(!obj.isNull("useCurves")){
		useCurves = obj.getBoolean("useCurves");
	}
	if(!obj.isNull("penSizeMM")){
		penSizeMM = obj.getFloat("penSizeMM");
		strokeSize = calculateStrokeSize();
	}
    if(!obj.isNull("noodleThicknessPct")){
        noodleThicknessPct = obj.getFloat("noodleThicknessPct");
    }
    if(!obj.isNull("numNoodles")){
        numNoodles = obj.getInt("numNoodles");
    }
	if(!obj.isNull("minLength")){
		minLength = obj.getInt("minLength");
	}
	if(!obj.isNull("maxLength")){
		maxLength = obj.getInt("maxLength");
	}
	if(!obj.isNull("graphics")){
		JSONArray gfx = obj.getJSONArray("graphics");
		graphicSets = new GraphicSet[gfx.size()];
		for(int i = 0; i < gfx.size(); i++) {
			GraphicSet set = new GraphicSet(gfx.getJSONObject(i));
			set.loadShapes();
			graphicSets[i] = set;
		}
		
	}
	if(!obj.isNull("randomizeEnds")){
		randomizeEnds = obj.getBoolean("randomizeEnds");
	}
	if(!obj.isNull("blackoutCells")){
		blackoutCells = new int[GRID_W][GRID_H];
		JSONArray cellsArray = obj.getJSONArray("blackoutCells");
		for(int col = 0; col < GRID_W; col++){
			JSONArray rowArray = cellsArray.getJSONArray(col);
			for(int row = 0; row < GRID_H; row++){
				blackoutCells[col][row] = rowArray.getInt(row);
			}
		}
	}


}

public void loadConfigFile(String filePath, String fileName) {
	JSONObject obj = null;
	JSONArray layerData = null;
	
	try {
		obj = loadJSONObject(filePath);
	} catch(Exception e) {
		println("Error: loaded data is not a JSON object");
	}
	
	if(obj != null) {
		parseConfigObject(obj);
	} 

	updateKeyDimensions();
	updateControllerValues();
}

public void updateSettingsFile() {
	println("Update settings: ");
	println(configPath);
	JSONObject json = new JSONObject();
	json.setString("configPath", configPath);
	saveJSONObject(json, "data/" + SETTINGS_PATH);
}

public void loadSettings(String filePath) {

	JSONObject settings = loadJSONObject(filePath);
	if(!settings.isNull("configPath")){
		String path = settings.getString("configPath");
		File f = new File(sketchPath(path));
		if (f.exists()) {
			configPath = path;
		} else {
			println("! ERROR: config file doesn't exist. Using default.");
		}
	}
}
static class ID {
    
// BUTTONS - LAYER A
static final int TWISTS = 1;
static final int JOINS = 2;
static final int OVERLAPS = 3;
static final int RANDOMIZE_ENDS = 4;

static final int RESET = 8;

static final int INFO = 9;
static final int GRID = 10;
static final int BLACKOUT = 11;
static final int PATH_EDIT = 12;

static final int LOAD = 15;
static final int SAVE = 16;

// KNOBS - LAYER A
static final int NOODLES = 1;
static final int THICKNESS = 2;
static final int PEN_SIZE = 3;
static final int MIN_LEN = 4;
static final int MAX_LEN = 5;

// KNOBS - LAYER B
static final int PAGEW = 9;
static final int PAGEH = 10;
static final int MARGIN = 11;
static final int COLS = 12;
static final int ROWS = 13;
}

XTouchMini xTouch;

public void setupController() {

    xTouch = new XTouchMini();

    for(int i = 1; i <= 12; i++){
        xTouch.setModeForButton(XTButton.MODE_TOGGLE, i);
    }
    xTouch.setModeForButton(XTButton.MODE_MOMENTARY, ID.RESET);

    xTouch.setRangeForKnob(3, 200, ID.NOODLES);
    xTouch.setRangeForKnob(0.1f, 1, ID.THICKNESS);
    xTouch.setRoundingConstraintsForKnob(0.01f, 2, ID.THICKNESS);
    xTouch.setRangeForKnob(0.1f, 2.0f, ID.PEN_SIZE);
    xTouch.setRoundingConstraintsForKnob(0.05f, 2, ID.PEN_SIZE);
    xTouch.setRangeForKnob(3, 400, ID.MIN_LEN);
    xTouch.setRangeForKnob(3, 400, ID.MAX_LEN);

    xTouch.setRangeForKnob(5, 24, ID.PAGEW);
    xTouch.setRoundingConstraintsForKnob(0.25f, 3, ID.PAGEW);
    xTouch.setRangeForKnob(5, 24, ID.PAGEH);
    xTouch.setRoundingConstraintsForKnob(0.25f, 3, ID.PAGEH);
    xTouch.setRangeForKnob(0, 5, ID.MARGIN);
    xTouch.setRoundingConstraintsForKnob(0.125f, 3, ID.MARGIN);
    xTouch.setRangeForKnob(1, 60, ID.COLS);
    xTouch.setRangeForKnob(1, 60, ID.ROWS);
}

public void updateControllerValues() {
    if(xTouch == null) return;
    xTouch.setValueForKnob(numNoodles, ID.NOODLES);
    xTouch.setValueForKnob(noodleThicknessPct, ID.THICKNESS);
    xTouch.setValueForKnob(penSizeMM, ID.PEN_SIZE);
    xTouch.setValueForKnob(minLength, ID.MIN_LEN);
    xTouch.setValueForKnob(maxLength, ID.MAX_LEN);
    
    xTouch.setValueForKnob(PRINT_W_INCHES, ID.PAGEW);
    xTouch.setValueForKnob(PRINT_H_INCHES, ID.PAGEH);
    xTouch.setValueForKnob(MARGIN_INCHES, ID.MARGIN);
    xTouch.setValueForKnob(GRID_W, ID.COLS);
    xTouch.setValueForKnob(GRID_H, ID.ROWS);

    xTouch.setValueForButton(useTwists, ID.TWISTS);
    xTouch.setValueForButton(useJoiners, ID.JOINS);
    xTouch.setValueForButton(allowOverlap, ID.OVERLAPS);
    xTouch.setValueForButton(randomizeEnds, ID.RANDOMIZE_ENDS);
    
}

public void buttonDidChange(XTButton button, boolean value) {
	println("buttonDidChange: (" + button.id + "): " + value);

    switch(button.id){
        case ID.TWISTS:
            useTwists = value;
        break;
        case ID.JOINS:
            useJoiners = value;
        break;
        case ID.OVERLAPS:
            allowOverlap = value;
        break;
        case ID.RANDOMIZE_ENDS:
            randomizeEnds = value;
        break;
        case ID.RESET:
            if(value) reset();
        break;

        case ID.INFO:
            showInfoPanel = value;
        break;
        case ID.GRID:
            showGrid = value;
            if(!showGrid){
                xTouch.setValueForButton(false, ID.BLACKOUT);
                xTouch.setValueForButton(false, ID.PATH_EDIT);
            }
        break;
        case ID.BLACKOUT:
            BLACKOUT_MODE = value;
            if(BLACKOUT_MODE) {
                xTouch.setValueForButton(false, ID.PATH_EDIT);
                xTouch.setValueForButton(true, ID.GRID);
            }
        break;
        case ID.PATH_EDIT:
            PATH_EDIT_MODE = value;
            if(PATH_EDIT_MODE) {
                xTouch.setValueForButton(false, ID.BLACKOUT);
                xTouch.setValueForButton(true, ID.GRID);
            }
        break;

        case ID.LOAD:
            if(value) selectConfigFile();
        break;
        case ID.SAVE:
            // if(value){
            //     fileNameToSave = getFileName();
	    	// 	imgSaver.begin(fileNameToSave);
            // }
        break;
    }
    editor.update();
}


public void knobDidChange(XTKnob knob, float oldValue, float newValue) {
	println("knobDidChange (" + knob.id + "): " + oldValue, newValue);

    switch(knob.id){
        case ID.NOODLES:
            numNoodles = PApplet.parseInt(newValue);
        break;
        case ID.THICKNESS:
            noodleThicknessPct = newValue;
        break;

        case ID.PEN_SIZE:
            penSizeMM = newValue;
            strokeSize =  calculateStrokeSize();
        break;
        case ID.MIN_LEN:
            minLength = PApplet.parseInt(newValue);
            if(minLength > maxLength){
                xTouch.setValueForKnob(minLength, ID.MAX_LEN);
            }
        break;
        case ID.MAX_LEN:
            maxLength = PApplet.parseInt(newValue);
            if(maxLength < minLength){
                xTouch.setValueForKnob(maxLength, ID.MIN_LEN);
            }
        break;

        case ID.PAGEW:
            PRINT_W_INCHES = newValue;
            updateKeyDimensions();
        break;
        case ID.PAGEH:
            PRINT_H_INCHES = newValue;
            updateKeyDimensions();
        break;
        case ID.MARGIN: 
            MARGIN_INCHES = newValue;
            updateKeyDimensions();
        break;
        case ID.COLS:
            GRID_W = PApplet.parseInt(newValue);
            updateKeyDimensions();
        break;
        case ID.ROWS:
            GRID_H = PApplet.parseInt(newValue);
            updateKeyDimensions();
        break;
    }

    editor.update();

}

public void knobDidPress(XTKnob knob) {
	println("knobDidPress: " + knob.id);

    switch(knob.id){
        case ID.PEN_SIZE:
            float val = 0.15f;
            if(penSizeMM < 0.9f){
                val = 1.0f;
            } else if(penSizeMM < 1.9f){
                val = 2.0f;
            } else {
                val = 0.15f;
            }

            xTouch.setValueForKnob(val, knob.id);
        break;
    }
    editor.update();
}

public void knobDidRelease(XTKnob knob) {
	println("knobDidRelease: " + knob.id);
}

public void faderDidChange(float oldValue, float newValue) {
	println("faderDidChange: " + oldValue, newValue);
}
public void importMaskImage() {

	selectInput("Load image mask", "onImageMaskSelected");

}

PImage maskImage = null;
public void onImageMaskSelected(File img) {
	shiftIsDown = false;
	if(img == null) return;
	
	String filePath = img.getAbsolutePath();
	
    maskImage = loadImage(filePath);
    processMaskData();
}


PGraphics mask = null;
public void processMaskData() {
    mask = createGraphics(GRID_W, GRID_H);
    mask.beginDraw();
    mask.background(0);

    // scale and center
    float scale = PApplet.parseFloat(GRID_W) / PApplet.parseFloat(maskImage.width);
    if(scale * maskImage.height > GRID_H) {
        scale = PApplet.parseFloat(GRID_H) / PApplet.parseFloat(maskImage.height);
    }
    float w = maskImage.width * scale;
    float h = maskImage.height * scale;
    float xPos = (GRID_W - w) / 2;
    float yPos = (GRID_H - h) / 2;

    mask.image(maskImage, xPos, yPos, w, h);
    mask.endDraw();

    mask.loadPixels();
    // loop through rows and cols in blackout cells
    for(int y = 0; y < GRID_H; y++) {
        for(int x = 0; x < GRID_W; x++) {
            
            // fucking retina displays make this complicated
            // why can't I create a PGraphics at an exact size?
            int xVal = x * mask.pixelDensity;
            int yVal = y * mask.pixelDensity;
            int index =( xVal + yVal * GRID_W * mask.pixelDensity) ;
            int c = mask.pixels[ index ];
            if(brightness(c) < 50) {
                blackoutCells[x][y] = CellType.BLACKOUT;
            } else {
                blackoutCells[x][y] = 0;
                
            }
        }
    }


}

public void drawInfoPanel() {
    fill(50, 150);
    noStroke();
    rect(8, 8, 264, 300, 8);

    fill(255);
    
    textFont(menloFont);
    textAlign(LEFT, TOP);
    text("       SIZE: " + PRINT_W_INCHES + " \u00d7 " + PRINT_H_INCHES, 32, 24);
    text("     MARGIN: " + MARGIN_INCHES+"\"", 32, 40);
    text("       GRID: " + GRID_W + " \u00d7 " + GRID_H, 32, 64);
    text("    NOODLES: " + numNoodles, 32, 88);
    text("  THICKNESS: " + round(noodleThicknessPct * 100) + "%", 32, 104);
    text("     LENGTH: " + minLength + " min, " + maxLength + " max", 32, 120);
    text("   PEN SIZE: " + penSizeMM + " mm", 32, 152);
    booleanText("     TWISTS: ", useTwists, 32, 184);
    booleanText("      JOINS: ", useJoiners, 32, 200);
    booleanText("   OVERLAPS: ", allowOverlap, 32, 216);
    booleanText("RANDOM ENDS: ", randomizeEnds, 32, 232);

}

public String getCheckMark(boolean val) {
    if(val){
        return "\u2716\ufe0f";
    } else {
        return " ";
    }
}

public void booleanText(String txt, boolean isOn, int px, int py) {
    if(isOn){
        fill(255);
    } else {
        fill(100);
    }

    text(txt + getCheckMark(isOn), px, py);
}
int NUM_JOIN_TYPES = 5;

public boolean cellIsEmpty(int px, int py) {
	return cells[px][py] == CellType.EMPTY;
}

public boolean cellIsInBounds(Point p) {
	boolean overMin = p.x >= 0 && p.y >= 0; 
	boolean underMax = p.x < cells.length && p.y < cells[0].length;

	return overMin && underMax;
}

public boolean canCrossCell(Point prev, String dir) {
	if(!allowOverlap) return false;

	boolean result = false;

	int perpCellType = -1;
	Point nextCell = null;
	Point afterCell = null;
	switch (dir) {
		case "up":
			perpCellType = CellType.HORIZONTAL;
			nextCell = new Point(prev.x, prev.y - 1);
			afterCell = new Point(prev.x, prev.y - 2);
		break;
		case "down":
			perpCellType = CellType.HORIZONTAL;
			nextCell = new Point(prev.x, prev.y + 1);
			afterCell = new Point(prev.x, prev.y + 2);
		break;

		case "left":
			perpCellType = CellType.VERTICAL;
			nextCell = new Point(prev.x - 1, prev.y);
			afterCell = new Point(prev.x - 2, prev.y);
		break;

		case "right": 
			perpCellType = CellType.VERTICAL;
			nextCell = new Point(prev.x + 1, prev.y);
			afterCell = new Point(prev.x + 2, prev.y);
		break;

	}

	if(nextCell != null && cellIsInBounds(nextCell) && cellIsInBounds(afterCell)){
		
		if(cells[nextCell.x][nextCell.y] == perpCellType){
			if(cells[afterCell.x][afterCell.y] == CellType.EMPTY) {
				result = true;
			}
		}
	}

	return result;
}

public void markCellTypeWithPathAndIndex(Point[] path, int i) {
	Point current = path[i];
	if(cells != null && current != null){
		if(i > 1){ 
			Point prev = path[i - 1];
			Point twoBack = path[i-2];

			if(twoBack.x == current.x){
				cells[prev.x][prev.y] = CellType.VERTICAL;
			} else if(twoBack.y == current.y){
				cells[prev.x][prev.y] = CellType.HORIZONTAL;
			}
		} 
	
		cells[current.x][current.y] = CellType.OCCUPIED;
	}
}

public boolean addCrossAtCell(Point cell, String dir) {
	int noodleNum = findNoodleWithCell(cell.x, cell.y);
	if(noodleNum >= 0){
		Noodle n = noodles[noodleNum];
		addCrossToPathAtCell(cell, n.path, dir);
		return true;
	}
	return false;
}

public void addCrossToPathAtCell(Point cell, Point[] path, String dir){
	int index = getIndexOfCell(cell.x, cell.y, path);
	if(dir == "up" || dir == "down" ){
		path[index].type = CellType.H_CROSSED;
	}else {
		path[index].type = CellType.V_CROSSED;
	}
}

public Point findStartPoint(int[][] cells) {
	int posX, posY;
	int numTries = 0;
	do {
		posX = floor(random(0, cells.length));
		posY = floor(random(0, cells[0].length));
		numTries++;

		if(numTries > 200){
			return null;
		}
	} while (cells[posX][posY] > 0);

	return new Point(posX, posY);
}

public ArrayList<String> findAvailableDirections(Point prev, boolean isLastCell) {
	int cols = cells.length;
	int rows = cells[0].length;

	boolean up = prev.y > 0 && (cellIsEmpty(prev.x, prev.y - 1) || (!isLastCell && canCrossCell(prev, "up")));
	boolean down = prev.y < rows-1 && (cellIsEmpty(prev.x, prev.y + 1) || (!isLastCell && canCrossCell(prev, "down")));
	boolean left = prev.x > 0 && (cellIsEmpty(prev.x - 1, prev.y) || (!isLastCell && canCrossCell(prev, "left")));
	boolean right = prev.x < cols-1 && (cellIsEmpty(prev.x + 1, prev.y) || (!isLastCell && canCrossCell(prev, "right" )));
	
	ArrayList<String> avail = new ArrayList<String>();
	if(up) avail.add("up");
	if(down) avail.add("down");
	if(left) avail.add("left");
	if(right) avail.add("right");

	return avail;
}

public Point getNextPointForDirection(Point prev, String dir) {
	Point p = null;
	if(dir == "up") p = (new Point(prev.x, prev.y -1));
	if(dir == "down") p = (new Point(prev.x, prev.y +1));
	if(dir == "right") p = (new Point(prev.x + 1, prev.y));
	if(dir == "left") p = ( new Point(prev.x -1, prev.y));
	return p;
}

public Point[] createNoodlePath(int[][] cells){	
	int len =  PApplet.parseInt(random(minLength, maxLength));
	Point[] path = new Point[len];
	
	Point start = findStartPoint(cells);
	if(start == null) return null;

	path[0] = start;
	cells[start.x][start.y] = CellType.OCCUPIED;
	
	int count = 1;
	for(int i=1; i < len; i++){
		
		Point prev = path[count-1];
		ArrayList<String> avail = findAvailableDirections(prev, i == len -1);
		
		if(avail.size() > 0){
			int index = floor(random(0, avail.size()));
			String dir = avail.get(index);

			Point p = getNextPointForDirection(prev, dir);
			if(p != null){
				if(!cellIsEmpty(p.x, p.y)) {
					boolean didAdd = addCrossAtCell(p, dir);
					if(!didAdd) {
						addCrossToPathAtCell(p, path, dir);
					}
				}

				p.joinType = floor(random(0, NUM_JOIN_TYPES));
				p.type = CellType.OCCUPIED;		
				path[count] = p;
				markCellTypeWithPathAndIndex(path, count);
				count++;
			}
		}
	}
	
	if(count > 2){
		Point[] finalPath = (Point[]) subset(path, 0, count);
		return finalPath;
	} else {
		clearCells(cells, (Point[]) subset(path, 0, count));
		return null;
	}

}

public void clearCells(int[][] cells, Point[] path){
	for(int i=0; i< path.length; i++){
		Point p = path[i];
		cells[p.x][p.y] = CellType.EMPTY;
	}
}

public void drawPath(Point[] path, int tileSize){
	fill(255, 200,200);
	stroke(255, 150, 150);
	for(int i = 0; i < path.length; i++){
		rect(path[i].x * tileSize, path[i].y * tileSize, tileSize, tileSize);
	}
}

public Point getCellForMouse( int mX, int mY){
	int cellX = (mouseX - canvasX - PRINT_X) / TILE_SIZE;
	int cellY = (mouseY - canvasY - PRINT_Y) / TILE_SIZE;

	return new Point(cellX, cellY);
}

public boolean cellsAreAdjacent(int c1X, int c1Y, int c2X, int c2Y){
	return (
		(c1X == c2X && abs(c1Y - c2Y) == 1) || 
		(c1Y == c2Y && abs(c1X - c2X) == 1)
	);
}

public boolean cellIsEndOfPath(int x, int y, Point[] path){
	Point first = path[0];
	Point last = path[path.length - 1];
	
	return ((first.x == x && first.y == y) || (last.x == x && last.y == y));
}

public int getIndexOfCell(int x, int y, Point[] path){
	if(path == null) return -1;
	for(int i = 0; i < path.length; i++){
		if(path[i] != null && path[i].x == x && path[i].y == y){
			return i;
		}
	}
	
	return -1;
}

public Point[] cycleCellType(int x, int y, Point[] path){
	int i = getIndexOfCell(x, y, path);
	path[i].joinType++;
	if(path[i].joinType >= NUM_JOIN_TYPES){
		path[i].joinType = 0;
	}
	
	return path;
} 

public Point[] addCellToPath(int cellX, int cellY, Point[] path){
	Point[] newPath = new Point[path.length + 1];
	Point first = path[0];
	Point last = path[path.length - 1];

	int fillIndex = 0;
	if(cellsAreAdjacent(first.x, first.y, cellX, cellY) ){
		newPath[0] = new Point(cellX, cellY);
		fillIndex = 1;
	} else if(cellsAreAdjacent(last.x, last.y, cellX, cellY)){
		newPath[path.length] = new Point(cellX, cellY);
	} else {
		return path;
	}

	for(Point p : path){
		newPath[fillIndex] = p;
		fillIndex++;
	}
	return newPath;
}

public Point[] removeCellFromPath(int cellX, int cellY, Point[] path) {
	Point[] newPath;
	if(path[0].x == cellX && path[0].y == cellY){
		newPath = java.util.Arrays.copyOfRange(path, 1, path.length);
		return newPath;
	} else if (path[path.length - 1].x == cellX && path[path.length - 1].y == cellY){
		newPath = java.util.Arrays.copyOfRange(path, 0, path.length-1);
		return newPath;
	} else {
		return path;
	}
	
}

public int findNoodleWithCell(int cellX, int cellY) {
	int index = 0;
	for(Noodle n : noodles){
		if(n != null && n.path != null){
			for(Point p : n.path){
				if(p.x == cellX && p.y == cellY){
					return index;
				}
			}
		}
		index++;
	}

	return -1;
}
int variance = 3;
int smoothness = 20;

public void roughLineH(int px, int py, float width) {
    
    float scale = width / 100;

    PVector p1 = new PVector(px, py);
    PVector mid = new PVector(px + width / 2, (random(-variance, variance) * scale) + py);

    PVector c1 = new PVector(px + (smoothness * scale), py);
    PVector c2 = new PVector(mid.x - (20 * scale), mid.y);

    PVector c3 = new PVector(mid.x + (20 * scale), mid.y);
    PVector c4 = new PVector(px + width - (smoothness * scale), py);

    PVector p2 = new PVector(px + width, py);
    
    drawRoughLine(p1, c1, c2, mid, c3, c4, p2);
}
    

public void roughLineV(int px, int py, float height) {
    float scale = height / 100;

    PVector p1 = new PVector(px, py);
    PVector mid = new PVector( (random(-variance, variance) * scale) + px, py + height / 2);

    PVector c1 = new PVector(px, py + (smoothness * scale));
    PVector c2 = new PVector(mid.x, mid.y - (20 * scale));

    PVector c3 = new PVector( mid.x, mid.y + (20 * scale) );
    PVector c4 = new PVector(px, py + height - (smoothness * scale));

    PVector p2 = new PVector(px, py + height);
    
    drawRoughLine(p1, c1, c2, mid, c3, c4, p2);
}

public void drawRoughLine(PVector p1, PVector c1, PVector c2, PVector mid, PVector c3, PVector c4, PVector p2) {
    stroke(0);
    bezier(p1.x,p1.y,   c1.x,c1.y,  c2.x,c2.y,  mid.x,mid.y);
    bezier(mid.x,mid.y, c3.x,c3.y,  c4.x,c4.y,  p2.x, p2.y);

}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "sketch" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
